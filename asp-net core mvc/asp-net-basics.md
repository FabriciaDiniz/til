- O .NET Core é um framework cross-plataforma e é também uma versão mais leve do .NET framework
    - é mais leve e flexível por ser mais modularizado
    - é mais indicado para implantação em containers, porque é mais leve devido à sua característica modular
- Existem variáveis de ambiente que indicam se a solução deve ser rodada em modo de desenvolvimento ou de produção, é possível mudar isso na aba de debug do projeto
    - a API de configuração consegue acessar configurações tanto de variáveis de sistema quanto de arquivos de settings
- O arquivo Startup.cs contém informações de configuração da aplicação
    - o método ConfigureServices serve para adicionar serviços à aplicação (banco de dados, log , monitoramento, mvc)
    - o método Configure serve como local onde os serviços adicionados serão utilizados
        - as requisições feitas no navegador seguem o fluxo descrito nesse método
- O arquivo launchSettings.json contém informações sobre a porta na qual a aplicação vai estar rodando, configurações do servidor
- O ASP.NET possui um modo de mostrar exceptions que detalha cookies, headers, etc, para o desenvolvedor, com o app.UseDeveloperExceptionPage()
    - depende da variável de ambiente indicar que a solução deve ser rodada em modo de desenvolvimento
- As interfaces são nomeadas com um "I" na frente do nome da classe e servem para reduzir o acoplamento do sistema
    - para conseguir fazer a injeção de dependências e obter as instâncias se utiliza o IServiceProvider, que é o provedor que obtém as instâncias das classes
        - o método que obtém as instâncias é o GetService<T>, porém precisa-se configurar o serviço que faz a conexão entre a interface e a classe concreta

- Roteamento
    - as funcionalidades de roteamento a seguir só são possíveis por causa do middleware UseMvc     
    - uma vez que as partes da url são mapeadas para os diferentes placeholders [vou inserir a tradução correta quando eu descobrir], o programa tenta achar os controllers e ações que correspondam a esses placeholders
        - para buscar os controllers, o programa procura todas as classes que contenham o sufixo Controller, remove esse sufixo do nome e tenta compará-lo com o placeholder vindo da url
        - depois, ele acha todos os métodos públicos daquele controller e os registra como possíveis ações, comparando com o placeholder vindo da url para achar o equivalente
        - é possível especificar um valor default para os diferentes placeholders, que faz com que eles não precisem vir na url e o programa ainda vai saber para onde mapear
            - a sintaxe fica: “{controller=Home}/{action=Index}/{id?}”, com o controller padrão sendo definido como home e a ação padrão sendo definida como Index
        - é possível especificar que determinada rota só será chamada quando o placeholder for do tipo apropriado
            - a sintaxe fica: “{controller=Home}/{action=Index}/{id:int?}", onde a rota q contém o id só será mapeada se ele for um inteiro
    - para customizar rotas para uma determinada ação, basta incluir Route acima do método passando a url customizada e incluir os parâmetros correspondentes na action
        - a sintaxe fica: [Route(blog/{year:int}/{month:int}/{key})]
        - a ordem dos placeholders não precisa ser a mesma ordem que os parâmetros são passados para a ação, porque eles são mapeados por nome
        - é possível aplicar diversas restrições nessa passagem da rota, a sintaxe ficaria: "blog/{year:min(2000)}/{month:range(1,12)}/{key}"
        - uma rota pode ser “quebrada”, colocando o nome do controller acima da classe para evitar ficar repetindo em todas as ações, porém fazer isso no controller faz com que as urls não possam mais ser gerenciadas pelo roteamento mais geral feito no app.UseMvc, o que faz com que qualquer valor default definido não se aplique e precise ser explicitado na classe do controller (usando, por exemplo, um [Route(“”)] para o index)

- Middleware
    - funções que são registradas para lidar com requisições em uma ordem específica
    - quando uma requisição chega, o .NET cria uma instância do pipeline e chama cada uma das funções, para que cada uma possa modificar a requisição antes que a resposta seja enviada para o usuário
    - podem ser reutilizados em diferentes aplicações (se forem genéricos o suficiente)
    - os mw são executados na ordem em que eles são registrados
    - invés de usar o padrão app.Run() que vem no arquivo padrão do projeto e encerra a cadeia de mw quando é executado, deve-se usar o app.Use(), que recebe o contexto e next, que leva para o mw seguinte
    - para executar um mw apenas em certo path, deve-se adicionar um if checando o path
        - context.Request.Path.Value.StartsWith()
    - para servir arquivos estáticos, deve-se utilizar o app.UseFileServer(), que vai analisar a requisição e tentar mapear ela com algum path registrado na pasta wwwroot ou com alguma view
        - na pasta wwwroot devem ser colocados todos os arquivos estáticos da aplicação, como css e imagens
    - o app.UseExceptionHandler() pega todas as exceções e trata, levando para uma página de erro apropriada
